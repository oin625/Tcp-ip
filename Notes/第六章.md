#### UDP 套接字的特点

UDP 提供的是一种不可靠的数据传输方式。只考虑可靠性的话，TCP的确比UDP好，但是UCDP在结构上比TCP更简洁。因此，UDP的性能有时会比TCP高出很多。但是也不会像想象中那么频繁的发生数据损毁。当更重视性能而并非可靠性的情况下，UDP非常的nice。

**UDP和TCP的差异只在于流控制机制**，所谓流控制机制，以我目前的个人理解，流控制机制呢就是控制数据传输的一些限制，比如TCP中的三次握手四次挥手，就是属于流控制机制。

**每次交换的数据量越大，TCP的传输速率就越接近UDP的传输速率。**也就是说，想要多次传输数据量较小的时候，UDP是很好的选择。

#### UDP 的工作原理

IP的作用前面在前面也提到过，就是让离开主机B的UDP数据包可以准确的传递到主机A。但是把 UDP 数据包最终交给主机 A 的某一 UDP 套接字的过程是由 UDP 完成的。**UDP 的最重要的作用就是根据端口号将传到主机的数据包交付给最终的 UDP 套接字。**

#### UDP 的高效使用

首先要知道，UDP也具有一定的可靠性。

但是当需要传递一个压缩文件的时候，却必须使用TCP，因为压缩文件只要丢失一部分就很难解压。

而通过网络实时传输视频或音频的情况，就相当于直播的情况就不一样 了。即使丢失掉一部分也问题不大。只会引起短暂的画面抖动或者杂音啥的。实时服务，速度才是非常重要的因素。此时控制流就会比较多余 了。所以就考虑使用UDP。

注意UDP并非每次都快于TCP。TCP比UDP慢的原因通常有以下两点。

- 收发数据前后进行的连接设置及清楚过程。
- 收发过程中为保证可靠性而添加的流控制。

如果收发的数据量小但是需要频繁连接时，UDP 比 TCP 更高效。

### 实现基于 UDP 的服务端/客户端

#### UDP 中的服务端和客户端没有连接

UDP 中的服务端和客户端不像 TCP 那样在连接状态下交换数据，因此与 TCP 不同，无需经过连接过程。也就是说，不必调用 TCP 连接过程中调用的 listen 和 accept 函数。UDP 中只有创建套接字和数据交换的过程。

####  UDP 服务器和客户端均只需一个套接字

TCP 中，套接字之间应该是一对一的关系。若要向 10 个客户端提供服务，除了守门的服务器套接字之外，还需要 10 个服务器套接字。但在 UDP 中，不管事服务器端还是客户端都只需要 1 个套接字。只需要一个 UDP 套接字就可以向任意主机传输数据

#### 基于 UDP 的数据 I/O 函数

创建好 TCP 套接字以后，传输数据时无需加上地址信息。因为 TCP 套接字将保持与对方套接字的连接。换言之，TCP 套接字知道目标地址信息。但 UDP 套接字不会保持连接状态（UDP 套接字只有简单的邮筒功能），因此每次传输数据时都需要添加目标的地址信息。这相当于寄信前在信件中填写地址。接下来是 UDP 的相关函数：

```
#include <sys/socket.h>
ssize_t sendto(int sock, void *buff, size_t nbytes, int flags,
               struct sockaddr *to, socklen_t addrlen);
/*
成功时返回传输的字节数，失败是返回 -1
sock: 用于传输数据的 UDP 套接字
buff: 保存待传输数据的缓冲地址值
nbytes: 待传输的数据长度，以字节为单位
flags: 可选项参数，若没有则传递 0
to: 存有目标地址的 sockaddr 结构体变量的地址值
addrlen: 传递给参数 to 的地址值结构体变量长度
*/
```

上述函数与之前的 TCP 输出函数最大的区别在于，此函数需要向它传递目标地址信息。接下来介绍接收 UDP 数据的函数。UDP 数据的发送并不固定，因此该函数定义为可接受发送端信息的形式，也就是将同时返回 UDP 数据包中的发送端信息。

```
#include <sys/socket.h>
ssize_t recvfrom(int sock, void *buff, size_t nbytes, int flags,
                 struct sockaddr *from, socklen_t *addrlen);
/*
成功时返回传输的字节数，失败是返回 -1
sock: 用于传输数据的 UDP 套接字
buff: 保存待传输数据的缓冲地址值
nbytes: 待传输的数据长度，以字节为单位
flags: 可选项参数，若没有则传递 0
from: 存有发送端地址信息的 sockaddr 结构体变量的地址值
addrlen: 保存参数 from 的结构体变量长度的变量地址值。
*/
```

编写 UDP 程序的最核心的部分就在于上述两个函数，这也说明二者在 UDP 数据传输中的地位。

#### 基于 UDP 的回声服务器端/客户端

下面是实现的基于 UDP 的回声服务器的服务器端和客户端：

代码：

- [uecho_client.c](https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch06/uecho_client.c)
- [uecho_server.c](https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch06/uecho_server.c)

编译运行：

```
gcc -o 1 uecho_server.c
gcc -o 2 uecho_client.c

./1 9190
./2 127.0.0.1 9190
```

TCP 客户端套接字在调用 connect 函数时自动分配IP地址和端口号，既然如此，UDP 客户端何时分配IP地址和端口号？好问题。

#### UDP 客户端套接字的地址分配

不给自己卖关子了。

调用 sendto 函数时自动分配IP和端口号，其中IP 用主机IP，端口号用未选用的任意端口号，因此，UDP 客户端中通常无需额外的地址分配过程。所以之前的示例中省略了该过程。这也是普遍的实现方式。

### UDP 的数据传输特性和调用 connect 函数

#### 存在数据边界的 UDP 套接字

前面提过好多次数据边界了，怎么通俗的理解这个名词呢。这里说到的是UDP有数据边界，按我个人理解，有数据边界可以理解为传输数据的容器相当于一个纸盒子，方方正正的，接受需要这么一个纸盒子，发送也是一样。规规整整的感觉。而对于TCP的无数据边界，就理解成一个包包，东西放的多了他会鼓起来，但是很能放些。东西放的少的话会很瘪大概就是这个感觉，自行理解理解。

专业术语。

TCP 数据传输中不存在数据边界，这表示「数据传输过程中调用 I/O 函数的次数不具有任何意义」

相反，UDP 是具有数据边界的协议，传输中调用 I/O 函数的次数非常重要。因此，输入函数的调用次数和输出函数的调用次数**完全一致**，这样才能保证接收全部已经发送的数据。例如，调用 3 次输出函数发送的数据必须通过调用 3 次输入函数才能接收完。不验证了。

#### 已连接（connect）UDP 套接字与未连接（unconnected）UDP 套接字

TCP 套接字中需注册待传传输数据的目标IP和端口号，而在 UDP 中无需注册。因此通过 sendto 函数传输数据的过程大概可以分为以下 3 个阶段：

- 第 1 阶段：向 UDP 套接字注册目标 IP 和端口号
- 第 2 阶段：传输数据
- 第 3 阶段：删除 UDP 套接字中注册的目标地址信息。

每次调用 sendto 函数时重复上述过程。每次都变更目标地址，因此可以重复利用同一 UDP 套接字向不同目标传递数据。这种未注册目标地址信息的套接字称为未连接套接字，反之，注册了目标地址的套接字称为连接 connected 套接字。显然，UDP 套接字默认属于未连接套接字。当一台主机向另一台主机传输很多信息时，上述的三个阶段中，第一个阶段和第三个阶段占整个通信过程中近三分之一的时间，缩短这部分的时间将会大大提高整体性能。

#### 创建已连接 UDP 套接字

上述代码看似与 TCP 套接字创建过程一致，但 socket 函数的第二个参数分明是 SOCK_DGRAM 。也就是说，创建的的确是 UDP 套接字。当然针对 UDP 调用 connect 函数并不是意味着要与对方 UDP 套接字连接，这只是向 UDP 套接字注册目标IP和端口信息。

之后就与 TCP 套接字一致，每次调用 sendto 函数时只需传递信息数据。因为已经指定了收发对象，所以不仅可以使用 sendto、recvfrom 函数，还可以使用 write、read 函数进行通信。









