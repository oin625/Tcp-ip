协议：为了完成数据交换而定好的约定。

```c
int sock = socket(PF_INIT, SOCK_STREAM, IPPROTO_TCP);
                  协议族     数据传输类型    决定协议
                            (套接字类型)
```

通过 socket 函数的第一个参数传递套接字中使用的协议分类信息。此协议分类信息称为协议族，可分成如下几类：

> 头文件 `sys/socket.h` 中声明的协议族

| 名称      | 协议族               |
| --------- | -------------------- |
| PF_INET   | IPV4 互联网协议族    |
| PF_INET6  | IPV6 互联网协议族    |
| PF_LOCAL  | 本地通信 Unix 协议族 |
| PF_PACKET | 底层套接字的协议族   |
| PF_IPX    | IPX Novel 协议族     |

**一个协议族中会存在多种套接字类型（数据传输方式）**

### 套接字类型

1.  面向连接的套接字(SOCK_STREAM)  
   * 可靠
   * 按序传递
   * 无数据边界(接收数据的次数和传输次数不相同)

2. 面向消息的套接字(SOCK_DGRAM)  
   * 不够可靠
   * 无序
   *  高速
   * 有数据边界(接受次数等同于传输次数)
   * 限制每次传输数据的大小。

收发数据的套接字内部有缓冲（buffer），简言之就是字节数组。只要不超过数组容量，那么数据填满缓冲后过 1 次 read 函数的调用就可以读取全部，也有可能调用多次来完成读取。

**套接字缓冲已满是否意味着数据丢失？**

> 答：缓冲并不总是满的。如果读取速度比数据传入过来的速度慢，则缓冲可能被填满，但是这时也不会丢失数据，因为传输套接字此时会停止数据传输。面向连接的套接字会根据接收端的状态传输数据。如果传输出错还会提供重传服务。所以面向连接的套接字不会发生数据丢失。



本书用的是 Ipv4 的协议族，和面向连接的数据传输，满足这两个条件的协议只有 TPPROTO_TCP ，因此可以如下调用 socket 函数创建套接字，这种套接字称为 TCP 套接字。

```c
itn tcp_socket = socket(PT_INET, SOCK_STREAM, IPPROTO_TCP);
```

SOCK_DGRAM 指的是面向消息的数据传输方式，满足上述条件的协议只有 TPPROTO_UDP 。这种套接字称为 UDP 套接字：

```c
int udp_socket = socket(PT_INET, SOCK_DGRAM, IPPROTO_UDP);
```





