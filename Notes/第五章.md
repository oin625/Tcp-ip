### 回声客户端的完美实现

回顾一下服务器端的 I/O 相关代码：

```
while ((str_len = read(clnt_sock, message, BUF_SIZE)) != 0)
    write(clnt_sock, message, str_len);
```

接着是客户端代码:

```
write(sock, message, strlen(message));
str_len = read(sock, message, BUF_SIZE - 1);
```

两者在循环调用read和wtite函数。实际上之前的回声客户端将 100% 接受字节传输的数据，只不过接受数据时的单位有些问题。

问题所在就是，回声客户端传输的是字符串，而且是通过调用 write 函数一次性发送的。之后还调用一次 read 函数，期待着接受自己传输的字符串。

#### 回声客户端问题的解决办法

这个问题其实很容易解决，因为可以提前确定接受数据的大小。如果之前传输了20字节长的字符串，则再接收时循环调用 read 函数读取 20 个字节即可。

#### 如果问题不在于回声客户端：定义应用层协议

回声客户端可以提前知道接收数据的长度，这在大多数情况下是不可能的。那么此时无法预知接收数据长度时应该如何手法数据？这是需要的是**应用层协议**的定义。在收发过程中定好规则（协议）以表示数据边界，或者提前告知需要发送的数据的大小。服务端/客户端实现过程中逐步定义的规则集合就是应用层协议。

现在写一个小程序来体验应用层协议的定义过程。要求：

1. 服务器从客户端获得多个数组和运算符信息。
2. 服务器接收到数字候对齐进行加减乘运算，然后把结果传回客户端。

例：

1. 向服务器传递3,5,9的同时请求加法运算，服务器返回3+5+9的结果
2. 请求做乘法运算，客户端会收到`3*5*9`的结果
3. 如果向服务器传递4,3,2的同时要求做减法，则返回4-3-2的运算结果。

请自己实现一个程序来实现功能。

我自己的实现，快速做了一个十以内的各种运算，很完美。当时做的时候没反应过来只能运算十以内的数，做完之后反应过来了，大致咋改也知道了。先不改，等时间充裕的时候再改改看看。

- [My_op_server.c](https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch05/My_op_server.c)
- [My_op_client.c](https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch05/My_op_client.c)

编译：

```
gcc -o 1 My_op_server.c
gcc -0 2 My_op_client.c
```

运行:

```
./1
./2
```